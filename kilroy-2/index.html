<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>KILROY - ljmakerportfolio</title><meta name="description" content="&nbsp; Kilroy was made from a chassis that was ordered from AliExpress, which I had to assemble myself. The materials&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://ljmaker.github.io/kilroy-2/"><link rel="alternate" type="application/atom+xml" href="https://ljmaker.github.io/feed.xml" title="ljmakerportfolio - RSS"><link rel="alternate" type="application/json" href="https://ljmaker.github.io/feed.json" title="ljmakerportfolio - JSON"><meta property="og:title" content="KILROY"><meta property="og:image" content="https://ljmaker.github.io/media/posts/3/KILRORYRaw.png"><meta property="og:image:width" content="1239"><meta property="og:image:height" content="739"><meta property="og:site_name" content="ljmakerportfolio"><meta property="og:description" content="&nbsp; Kilroy was made from a chassis that was ordered from AliExpress, which I had to assemble myself. The materials&hellip;"><meta property="og:url" content="https://ljmaker.github.io/kilroy-2/"><meta property="og:type" content="article"><link rel="stylesheet" href="https://ljmaker.github.io/assets/css/style.css?v=74f838951fac6f2cfe001a386a288c7d"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ljmaker.github.io/kilroy-2/"},"headline":"KILROY","datePublished":"2025-03-31T17:09+02:00","dateModified":"2025-03-25T23:47+01:00","image":{"@type":"ImageObject","url":"https://ljmaker.github.io/media/posts/3/KILRORYRaw.png","height":739,"width":1239},"description":"&nbsp; Kilroy was made from a chassis that was ordered from AliExpress, which I had to assemble myself. The materials&hellip;","author":{"@type":"Person","name":"Lovro Joksimović","url":"https://ljmaker.github.io/authors/lovro-joksimovic/"},"publisher":{"@type":"Organization","name":"Lovro Joksimović"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template lines"><div class="container lines lines--right"><header class="header"><a href="https://ljmaker.github.io/" class="logo">ljmakerportfolio</a></header><main class="main post"><article class="content"><header class="content__inner content__header"><h1 class="content__title">KILROY</h1><div class="content__meta"><div class="content__meta__left"><a href="https://ljmaker.github.io/authors/lovro-joksimovic/" class="invert content__author" rel="author" title="Lovro Joksimović">Lovro Joksimović</a></div><div class="content__meta__right"><time datetime="2025-03-31T17:09" class="content__date">March 31, 2025</time><div class="content__updated">Updated on <time datetime="2025-03-31T17:09" class="content__date">March 25, 2025</time></div></div></div></header><figure class="content__featured-image"><div class="content__featured-image__inner is-img-loading"><img src="https://ljmaker.github.io/media/posts/3/KILRORYRaw.png" srcset="https://ljmaker.github.io/media/posts/3/responsive/KILRORYRaw-xs.png 384w, https://ljmaker.github.io/media/posts/3/responsive/KILRORYRaw-sm.png 600w, https://ljmaker.github.io/media/posts/3/responsive/KILRORYRaw-md.png 768w, https://ljmaker.github.io/media/posts/3/responsive/KILRORYRaw-lg.png 1200w, https://ljmaker.github.io/media/posts/3/responsive/KILRORYRaw-xl.png 1600w" sizes="(min-width: 37.5em) 1600px, 80vw" loading="eager" height="739" width="1239" alt=""></div><figcaption>Autonomous track robot. Year of making 2018</figcaption></figure><div class="content__inner"><div class="content__entry"><p>&nbsp;</p><h2 id="the-goal-was-to-learn-how-to-control-motors-and-various-sensors-with-a-microcontroller">The goal was to learn how to control motors and various sensors with a microcontroller</h2><p>Kilroy was made from a chassis that was ordered from AliExpress, which I had to assemble myself. The materials used were acrylic for the top layer, aluminium for the bottom layer and plastic for the tracks.&nbsp;</p><div class="gallery-wrapper"><div class="gallery" data-columns="2"><figure class="gallery__item"><a href="https://ljmaker.github.io/media/posts/3/gallery/DSC_0342.JPG" data-size="4208x2368"><img loading="lazy" src="https://ljmaker.github.io/media/posts/3/gallery/DSC_0342-thumbnail.JPG" height="432" width="768" alt=""></a></figure><figure class="gallery__item"><a href="https://ljmaker.github.io/media/posts/3/gallery/DSC_0343.JPG" data-size="4208x2368"><img loading="lazy" src="https://ljmaker.github.io/media/posts/3/gallery/DSC_0343-thumbnail.JPG" height="432" width="768" alt=""></a></figure></div></div><h2 id="kilroy-had-two-modes-mode-1-was-for-remote-control-and-mode-two-for-obstacle-avoidance">KILROY had two modes - mode 1 was for remote control and mode two for obstacle avoidance</h2><p>The final version had a light sensor for measuring light intensity and turning on LED's when it got too dark, an ultrasonic sensor for autonomous driving and obstacle avoidance, an I2C LCD display (on later model)&nbsp; that showed the current active mode and light intensity and an IR receiver module used for remote control with a TV remote. It also had a pushbutton and a switch mounted on the breadboard. The microcontroller used was Arduino UNO.&nbsp;&nbsp;</p><figure class="post__image post__image--center"><img loading="lazy" src="https://ljmaker.github.io/media/posts/3/KILROYAnnotated.png" height="739" width="1239" alt="" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://ljmaker.github.io/media/posts/3/responsive/KILROYAnnotated-xs.png 384w, https://ljmaker.github.io/media/posts/3/responsive/KILROYAnnotated-sm.png 600w, https://ljmaker.github.io/media/posts/3/responsive/KILROYAnnotated-md.png 768w, https://ljmaker.github.io/media/posts/3/responsive/KILROYAnnotated-lg.png 1200w, https://ljmaker.github.io/media/posts/3/responsive/KILROYAnnotated-xl.png 1600w"></figure><p>Two motors were controlled by a now outdated L298N dual channel motor driver, which produced a lot of heat so I mounted it directly on the aluminium for cooling.</p><h2 id="3d-model-was-made-in-fusion-360-and-the-circuit-in-fritzing">3d model was made in Fusion 360 and the circuit in Fritzing</h2><p>This circuit was made for the first model. It didn't feature a display</p><p></p><figure class="post__image post__image--center"><img loading="lazy" src="https://ljmaker.github.io/media/posts/3/KILROYCircuit.png" height="822" width="783" alt="" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://ljmaker.github.io/media/posts/3/responsive/KILROYCircuit-xs.png 384w, https://ljmaker.github.io/media/posts/3/responsive/KILROYCircuit-sm.png 600w, https://ljmaker.github.io/media/posts/3/responsive/KILROYCircuit-md.png 768w, https://ljmaker.github.io/media/posts/3/responsive/KILROYCircuit-lg.png 1200w, https://ljmaker.github.io/media/posts/3/responsive/KILROYCircuit-xl.png 1600w"></figure><p>The robot worked as intended, with the only problem being that I couldn't mount the display to the acrylic so it kept falling off. This was later fixed by supergluing it. Also, the battery pack had a very short lifespan of about 2 hours max. I remember having trouble finding the right power source for this project and this one definitely wasn't ideal.&nbsp;</p><figure class="post__image post__image--center"><img loading="lazy" src="https://ljmaker.github.io/media/posts/3/KILROYPic.JPG" height="2368" width="4208" alt="" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://ljmaker.github.io/media/posts/3/responsive/KILROYPic-xs.JPG 384w, https://ljmaker.github.io/media/posts/3/responsive/KILROYPic-sm.JPG 600w, https://ljmaker.github.io/media/posts/3/responsive/KILROYPic-md.JPG 768w, https://ljmaker.github.io/media/posts/3/responsive/KILROYPic-lg.JPG 1200w, https://ljmaker.github.io/media/posts/3/responsive/KILROYPic-xl.JPG 1600w"></figure><div><iframe loading="lazy" src="https://drive.google.com/file/d/1OdtUh5tx8QpUVuGK8y5YTkqmVqAv6cIO/preview" width="640" height="360" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div><h2 id="the-old-code-was-very-simple-made-in-arduino-ide">The old code was very simple, made in Arduino IDE</h2><pre class="line-numbers language-cpp"><code>#include &lt;IRremote.h&gt;
#include &lt;Wire.h&gt;
#include &lt;LiquidCrystal_I2C.h&gt;
#include &lt;NewPing.h&gt;

#define IR_RECEIVER_PIN 2
#define LIGHT_SENSOR_PIN 5
#define ULTRASONIC_TRIGGER_PIN 3
#define ULTRASONIC_ECHO_PIN 4
#define PUSHBUTTON_PIN 6
#define MOTOR1_PIN1 13
#define MOTOR1_PIN2 12
#define MOTOR2_PIN1 11
#define MOTOR2_PIN2 10
#define ENABLE_PIN_M1 9
#define ENABLE_PIN_M2 8
#define LCD_SWITCH_PIN 7 
#define LED1_PIN A0      
#define LED2_PIN A1      


#define IR_BUTTON_UP 0xFF18E7
#define IR_BUTTON_DOWN 0xFF4AB5
#define IR_BUTTON_LEFT 0xFF10EF
#define IR_BUTTON_RIGHT 0xFF5AA5
#define IR_BUTTON_STOP 0xFF38C7


#define MODE_REMOTE_CONTROL 0
#define MODE_OBSTACLE_AVOIDANCE 1

int currentMode = MODE_REMOTE_CONTROL;
bool lcdOn = true;
unsigned long lastDebounceTime = 0;
unsigned long debounceDelay = 50;

IRrecv irReceiver(IR_RECEIVER_PIN);
decode_results irResults;
LiquidCrystal_I2C lcd(0x27, 16, 2); 
NewPing sonar(ULTRASONIC_TRIGGER_PIN, ULTRASONIC_ECHO_PIN, 200); 

void setup() {
  
  pinMode(MOTOR1_PIN1, OUTPUT);
  pinMode(MOTOR1_PIN2, OUTPUT);
  pinMode(MOTOR2_PIN1, OUTPUT);
  pinMode(MOTOR2_PIN2, OUTPUT);
  pinMode(ENABLE_PIN_M1, OUTPUT);
  pinMode(ENABLE_PIN_M2, OUTPUT);
  pinMode(PUSHBUTTON_PIN, INPUT_PULLUP);
  pinMode(LCD_SWITCH_PIN, INPUT_PULLUP);
  pinMode(LIGHT_SENSOR_PIN, INPUT);
  pinMode(LED1_PIN, OUTPUT);
  pinMode(LED2_PIN, OUTPUT);

  
  irReceiver.enableIRIn();

 
  lcd.begin();
  lcd.backlight();
  lcd.print("Kilroy Ready!");
  delay(1000);
  lcd.clear();
}

void loop() {
  
  if (digitalRead(LCD_SWITCH_PIN)) {
    lcdOn = true;
    lcd.backlight();
  } else {
    lcdOn = false;
    lcd.noBacklight();
  }

  
  int lightValue = analogRead(LIGHT_SENSOR_PIN);
  if (lightValue &lt; 500) { // Adjust threshold as needed
    digitalWrite(LED1_PIN, HIGH);
    digitalWrite(LED2_PIN, HIGH);
  } else {
    digitalWrite(LED1_PIN, LOW);
    digitalWrite(LED2_PIN, LOW);
  }

  
  if (digitalRead(PUSHBUTTON_PIN) == LOW && (millis() - lastDebounceTime) &gt; debounceDelay) {
    lastDebounceTime = millis();
    currentMode = !currentMode; // Toggle mode
    lcd.clear();
    lcd.print("Mode: ");
    lcd.print(currentMode == MODE_REMOTE_CONTROL ? "Remote" : "Avoid");
  }

  
  if (currentMode == MODE_REMOTE_CONTROL) {
    remoteControlMode();
  } else {
    obstacleAvoidanceMode();
  }
}

void remoteControlMode() {
  if (irReceiver.decode(&irResults)) {
    switch (irResults.value) {
      case IR_BUTTON_UP:
        moveForward();
        break;
      case IR_BUTTON_DOWN:
        moveBackward();
        break;
      case IR_BUTTON_LEFT:
        turnLeft();
        break;
      case IR_BUTTON_RIGHT:
        turnRight();
        break;
      case IR_BUTTON_STOP:
        stopMotors();
        break;
    }
    irReceiver.resume();
  }
}

void obstacleAvoidanceMode() {
  int distance = sonar.ping_cm();
  if (distance &gt; 0 && distance &lt; 20) { // Obstacle within 20cm
    stopMotors();
    delay(500);
    turnRight();
    delay(500);
  } else {
    moveForward();
  }
}

void moveForward() {
  digitalWrite(MOTOR1_PIN1, HIGH);
  digitalWrite(MOTOR1_PIN2, LOW);
  digitalWrite(MOTOR2_PIN1, HIGH);
  digitalWrite(MOTOR2_PIN2, LOW);
  analogWrite(ENABLE_PIN_M1, 255);
  analogWrite(ENABLE_PIN_M2, 255);
}

void moveBackward() {
  digitalWrite(MOTOR1_PIN1, LOW);
  digitalWrite(MOTOR1_PIN2, HIGH);
  digitalWrite(MOTOR2_PIN1, LOW);
  digitalWrite(MOTOR2_PIN2, HIGH);
  analogWrite(ENABLE_PIN_M1, 255);
  analogWrite(ENABLE_PIN_M2, 255);
}

void turnLeft() {
  digitalWrite(MOTOR1_PIN1, LOW);
  digitalWrite(MOTOR1_PIN2, HIGH);
  digitalWrite(MOTOR2_PIN1, HIGH);
  digitalWrite(MOTOR2_PIN2, LOW);
  analogWrite(ENABLE_PIN_M1, 255);
  analogWrite(ENABLE_PIN_M2, 255);
}

void turnRight() {
  digitalWrite(MOTOR1_PIN1, HIGH);
  digitalWrite(MOTOR1_PIN2, LOW);
  digitalWrite(MOTOR2_PIN1, LOW);
  digitalWrite(MOTOR2_PIN2, HIGH);
  analogWrite(ENABLE_PIN_M1, 255);
  analogWrite(ENABLE_PIN_M2, 255);
}

void stopMotors() {
  digitalWrite(MOTOR1_PIN1, LOW);
  digitalWrite(MOTOR1_PIN2, LOW);
  digitalWrite(MOTOR2_PIN1, LOW);
  digitalWrite(MOTOR2_PIN2, LOW);
}</code></pre></div><footer class="content__footer"><div class="content__tag-share"><div class="content__share"></div></div></footer></div></article></main><footer class="footer"><div class="footer__left"><div class="footer__copy">Powered by Publii</div></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg><use xlink:href="https://ljmaker.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = { mobileMenuMode: 'sidebar', animationSpeed: 300, submenuWidth: 'auto', doubleClickTime: 500, mobileMenuExpandableSubmenus: true, relatedContainerForOverlayMenuSelector: '.navbar', };</script><script defer="defer" src="https://ljmaker.github.io/assets/js/scripts.min.js?v=9c5ab7a87221183f149a42b3cceb7956"></script><script>function publiiDetectLoadedImages () {
         var images = document.querySelectorAll('img[loading]:not(.is-loaded)');
         for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
               images[i].classList.add('is-loaded');
               images[i].parentNode.classList.remove('is-img-loading');
            } else {
               images[i].addEventListener('load', function () {
                  this.classList.add('is-loaded');
                  this.parentNode.classList.remove('is-img-loading');
               }, false);
            }
         }
      }
      publiiDetectLoadedImages();</script></body></html>